# 배열(array) vs. 리스트(list)
가장 기본적인 순차적인(sequential) 자료구조

## 제공 연산
C의 배열은 읽기와 쓰기만 제공하지만, Python의 리스트는 그 외 다양한 연산을 제공함
### 배열 (C언어)
index로 배열에 있는 특정 위치의 값을 상수시간 내에 읽고 쓸 수 있는 기본연산을 제공하는 자료 구조
```c
int A[4] = {2, 4, 0, 5};
```
C언어에서는 위와 같은 방법으로 배열을 선언함\
A는 A[0]의 첫번째 byte의 주소를 가리킴 (정수 배열이므로 각각 4bytes)\
`A[2] = A[2]+1`을 수행하면, (1)읽기 (2)산술 (3)대입 (4)쓰기 연산을 수행하게 되며 각 연산은 기본연산으로 상수시간이 소요됨\
RAM 모델에서는 "A[2]의 주소 = A[0]의 주소 + 2*4bytes"(+, * 기본연산 2회 수행)로 A[2]의 주소를 계산, $O(1)$으로 읽기가 가능

### 리스트 (Python)
배열과 유사하나 더 많은 종류의 연산을 제공하며 유연한 연산들이 가능함
```python
A = [2, 4, 0, 5]
```
Python에서 위와 같이 리스트를 정의함\
2, 4, 0, 5라는 객체가 따로 메모리에 저장되며
A[0]은 2가 저장된 곳의 주소, A[1]은 4가 저장된 곳의 주소, A[2]는 0, A[3]은 5가 저장된 곳의 주소를 가리킴\
`A[2] = A[2]+1`을 수행하면, (0에 1을 덮어쓰는 것이 아니라) 1이 라는 객체가 신규로 생성되고, A[2]가 1이 저장된 곳의 주소를 가리키게 됨

그 외 연산:
- A.append(6): 맨 뒤에 6을 삽입
- A.pop(): 맨 뒤의 값을 지우고 리턴
- A.pop(1): A[1]을 제거하고 리턴
- A.insert(1, 10): A[1]에 10을 삽입
- A.remove(value): A에서 처음으로 등장하는 value를 찾아서 제거
- A.index(value): A에서 처음으로 등장하는 value의 index 리턴
- A.count(value): A에서 value가 등장하는 횟수를 리턴

## 용량 자동조절 (Dynamic array)
### 배열 (C언어)
C에서는 선언한 것보다 크거나 작은 배열이 필요할 때 프로그래머가 직접 코드상에서 조정을 해줘야함
```c
int A[4] = {2, 4, 0, 5};
// 추가 정수 삽입을 위해서는 사용자가 메모리 할당을 해야함
B = (int*)malloc(6*4) // 정수 6개를 위한 메모리(24 bytes)를 할당하여 그 시작 주소를 B에 저장
A = B // A가 다시 B를 가리키도록 함으로써 A는 기존 16 bytes에서 24 bytes로 이사한 것이 됨
```

### 리스트 (Python)
Python의 리스트는 용량을 자동으로 조절함

```python
import sys
A = [] # 빈리스트 정의
print(sys.getsizeof(A)) # 빈 리스트에 할당된 메모리 확인
A.append(10) # A = [10]
print(sys.getsizeof(A)) # 다시 A에 할당된 메모리 확인
```
리스트 객체 A에는 용량(capacity)에 대한 정보와 저장될 값의 개수(n)가 포함됨

`A.append(x)`를 실행하면, 아래와 같은 로직을 거치게 됨
```python
if A.n < A.capacity: # A에 남은 capacity가 있을 때
    A[n] = x
    A.n = n+1
else: # A에 남은 capacity가 없을 때
    B = A.capacity*2 # A보다 크기가 큰 리스트를 새로 할당
    for i in range(n): # O(n)의 연산시간
        B[i] = A[i] # A의 데이터를 B로 복사
    del A # A를 삭제
    A = B # A가 B의 주소를 가리킴
    A[n] = x # 추가 데이터 쓰기
    A.n = n + 1 # 저장 값의 개수 업데이트
```